#' An alternative to \code{summaryRprof()}
#' 
#' \code{proftools} parses a profiling file and prints an easy-to-understand
#' table showing the most time-intensive function calls. 
#' 
#' Line numbers are #' included if \code{Rprof()} was run with 
#' \code{line.numbering=TRUE}. If it was run with \code{memory.profiling=TRUE},
#' this function will probably break.
#' 
#' Below the table are printed any files identified if line numbering is true,
#' the total time recorded by \code{Rprof()}, and the "parent call".  The
#' parent call consists of the parent call stack of all the call stacks in the\
#' table. Note that this is the parent call stack of only the printed lines,
#' not of all stacks recorded by \code{Rprof()}. This makes the table easier to. 
#' 
#' @export
#' @param file A profiling file generated by \code{Rprof()}
#' @param lines The number of lines (call stacks) you want returned. Lines are
#' printed from most time-intensive to least.  Only a few 
pproftable <- function(filename, lines = 10) {
  con <- file(filename, "rt")
  on.exit(close(con))
  profdata <- readLines(con)
  interval <- as.numeric(strsplit(profdata[1L], "=")[[1L]][2L]) / 1e+06
  filelines <- grep("^#File [0-9]+: ", profdata)
  files <- profdata[filelines]
  filenums <- as.integer(gsub("^#File ([0-9]+): .*", "\\1", files))
  filenames <- gsub("^#File [0-9]+: ", "", files)
  if (length(filelines))
    profdata <- profdata[-1:-filelines]
  ncalls <- length(profdata)
  total.time <- interval * ncalls
  profdata <- gsub("\\\"| $", "", profdata)
  profdata <- strsplit(profdata, " ")
  calls <- lapply(profdata, function(x) rev(x))
  min.len <- min(sapply(calls, length))
  parent.call <- unlist(lapply(seq_len(min.len), function(i) Reduce(intersect, lapply(unique(calls), "[[", i))))
  calls <- lapply(calls, function(x) setdiff(x, parent.call))
  stacktable <- as.data.frame(table(sapply(calls, function(x) paste(x, collapse = " > "))) / ncalls * 100, stringsAsFactors = FALSE)
  stacktable <- stacktable[order(stacktable$Freq[], decreasing = TRUE), 2:1]
  colnames(stacktable) <- c("PctTime", "Call")
  rownames(stacktable) <- NULL
    stacktable <- head(stacktable, lines)
  if (length(parent.call) > 0)
    parent.call <- paste(parent.call, collapse = " > ")
  else
    parent.call <- "None"
  frac <- sum(stacktable$PctTime)
  result <- list(calls = calls, stacktable = stacktable, parent.call = parent.call, interval = interval, total.time = total.time, files = filenames, total.pct.time = frac)
  class(result) <- "proftable"
  return(result)
}
 
print.proftable <- function(x) {
  print(x$stacktable, row.names=FALSE, right=FALSE, digits=3)
  cat("\nFiles:\n")
  cat(paste(x$files, collapse="\n"))
  cat("\n\n")
  cat(paste("Parent Call:", x$parent.call))
  cat("\n\n")
  cat(paste("Total Time:", x$total.time, "seconds"))
  cat("\n")
  cat(paste0("Percent of run time represented: ", format(x$total.pct.time, digits = 3), "%"))
}
